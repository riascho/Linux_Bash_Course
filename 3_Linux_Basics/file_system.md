# Linux File System

<!-- Generated by Copilot -->

## The Unix Philosophy: Everything is a File

One of the core principles of Unix/Linux is that **everything is treated as a file**. This unified approach simplifies system operations and provides a consistent interface for interacting with different system resources.

## File Types

Linux recognizes several different types of files, each identified by a specific character in the file listing:

| Type             | Symbol | Description                                                                |
| ---------------- | ------ | -------------------------------------------------------------------------- |
| Ordinary file    | `-`    | Regular files (text, binary, executables)                                  |
| Directory        | `d`    | Container for files and other directories                                  |
| Symbolic link    | `l`    | Reference/shortcut to another file or directory                            |
| Character device | `c`    | Device that handles data character by character (e.g., keyboard, terminal) |
| Block device     | `b`    | Device that handles data in blocks (e.g., hard drives)                     |
| Named pipe       | `p`    | Special file for inter-process communication                               |
| Socket           | `s`    | Special file for network communication                                     |

### Viewing File Types

To see the type of a file, use the `ls -l` command:

```bash
ls -l [folder/file]
# The first character indicates the file type
# Example output:
# drwxr-xr-x   7 ria  staff   224 Dec  3 17:03 a_folder
# ^
# └─ 'd' indicates this is a directory
```

To include hidden files (those starting with `.`):

```bash
ls -la [folder/file]
```

---

## Symbolic Links (Symlinks)

### What are Symlinks?

Symbolic links, also called **softlinks**, are special files that serve as references or "shortcuts" to another file or directory. When you access a symlink, the system automatically redirects you to the target file.

**Key characteristics:**

- Acts as a pointer to another file or directory's path
- Can cross filesystem boundaries
- Can link to directories
- If the target is deleted, the symlink becomes "broken"
- Access rights are determined by the target file, not the symlink itself

### Common Use Cases

- Creating convenient access points to frequently used directories
- Maintaining multiple references to the same file without duplication
- Linking configuration files across different locations
- Creating version-agnostic paths (e.g., `/usr/bin/python` → `/usr/bin/python3.11`)

### Creating a Symlink

Use the `ln` command with the `-s` flag:

```bash
ln -s [target] [link_name]

# Example: Create a symlink to Desktop
ln -s ~/Desktop/ linkToDesktop

# Now you can navigate using the symlink
cd linkToDesktop
```

**Note:** Changes made through either the symlink or the original path affect the same underlying file—both paths remain synchronized.

---

## Hard Links

### What are Hard Links?

A hard link is a directory entry that points directly to an existing inode (the actual data on disk). Unlike symlinks, hard links are **not separate files**—they are simply additional names for the same file.

**Key characteristics:**

- Multiple filenames pointing to the same inode
- All hard links are equal—there's no "original" file
- Must be on the same filesystem (cannot cross filesystem boundaries)
- Cannot be created for directories (with rare exceptions)
- The file data is only deleted when all hard links are removed

### Creating a Hard Link

Use the `ln` command without the `-s` flag:

```bash
ln [target] [hardlink]

# Example:
ln original.txt copy.txt
# Both files now point to the same data
```

### Copying Files with Hard Links

You can efficiently copy an entire directory structure using hard links, which saves disk space:

```bash
cp -al [source] [destination]
```

This creates a copy of the source folder structure where all files are hard-linked rather than duplicated. **No additional storage is needed** for the file content—only the directory structure uses new space.

## Inode

An inode is a filesystem data structure that stores a file's metadata and pointers to its data, but not the filename. It includes:

- File size
- Permissions
- Owner
- Timestamps
- Location of the file's data blocks

Filenames are stored in directories and mapped to inodes.

### Inode Limits

When a file is created, the filesystem allocates an inode to store its metadata. This inode occupies disk space that is permanently reserved for metadata and cannot be reused for file data. Most filesystems create a fixed number of inodes when the filesystem is formatted. If a system creates many small files, it can run out of available inodes even if there is still free disk space. When this happens, no new files can be created because there are no remaining inodes to store their metadata.

Check inode usage:

```bash
df -if
# disk free -inodes human-readable
```

---

## Symlink vs. Hardlink

### Hard Link

- Another name for the same file
- Both filenames point directly to the same inode (the file's data on disk)
- No "original" file—all hard links are equal

### Symbolic Link (Symlink / Soft Link)

- A special file that contains a path to another file
- Points to the name/location, not directly to the data
- Like a shortcut

### Visual Analogy

- **Hard link:** Two labels on the same physical box
- **Symlink:** A note that says "the box is in room B"

### When to Use Which

**Use hard links when:**

- You want guaranteed access to the data
- You don't want links to break if files are moved
- Everything is on the same filesystem

**Use symlinks when:**

- You need cross-filesystem links
- You want to link directories
- You want shortcut-like behavior
